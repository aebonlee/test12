# 기업가치평가 플랫폼 엔진 개발 계획서

**작성일:** 2025-10-17
**버전:** V1.0
**목적:** 5대 평가법 계산 엔진 및 보고서 작성 엔진 개발 마스터플랜

---

## 목차

1. [전체 아키텍처 개요](#1-전체-아키텍처-개요)
2. [공통 인프라 설계](#2-공통-인프라-설계)
3. [평가법별 엔진 설계](#3-평가법별-엔진-설계)
   - 3.1 DCF 평가법 엔진
   - 3.2 상대가치평가법 엔진
   - 3.3 자산가치평가법 엔진
   - 3.4 자본시장법평가법 엔진
   - 3.5 상증세법평가법 엔진
4. [보고서 작성 엔진 설계](#4-보고서-작성-엔진-설계)
5. [데이터 요구사항](#5-데이터-요구사항)
6. [기술 스택](#6-기술-스택)
7. [개발 Phase 계획](#7-개발-phase-계획)

---

## 1. 전체 아키텍처 개요

### 1.1 시스템 구성도

```
┌─────────────────────────────────────────────────────────────┐
│                    사용자 인터페이스 (UI)                      │
│              (Web/Mobile/Desktop Application)               │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                  API Gateway & Router                        │
│           (평가법 선택, 권한 관리, 세션 관리)                   │
└─────────────────────────┬───────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
┌───────▼────────┐ ┌─────▼──────┐ ┌───────▼────────┐
│  계산 엔진 모듈  │ │ 데이터 모듈 │ │ 보고서 엔진 모듈 │
│                │ │            │ │                │
│ - DCF 엔진     │ │ - 재무제표  │ │ - 템플릿 엔진   │
│ - 상대가치 엔진 │ │ - 시장데이터│ │ - PDF 생성     │
│ - 자산가치 엔진 │ │ - 벤치마크  │ │ - Excel 출력   │
│ - 자본시장 엔진 │ │ - 거시경제  │ │ - 차트/그래프   │
│ - 상증세 엔진   │ │ - 법규정보  │ │ - 민감도분석   │
└────────────────┘ └────────────┘ └────────────────┘
        │                 │                 │
        └─────────────────┼─────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                   Database Layer                             │
│  - 재무제표 DB  - 시장데이터 DB  - 평가결과 DB  - 사용자 DB  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 설계 원칙

1. **모듈화 (Modularity)**: 각 평가법 엔진은 독립적으로 개발/테스트/배포 가능
2. **확장성 (Scalability)**: 신규 평가법 추가 시 기존 시스템 영향 최소화
3. **재사용성 (Reusability)**: 공통 계산 로직, 검증 로직 라이브러리화
4. **정확성 (Accuracy)**: 모든 계산식에 대한 단위 테스트 및 검증 프로세스
5. **감사가능성 (Auditability)**: 모든 계산 과정과 가정 사항 기록 및 추적
6. **유연성 (Flexibility)**: 법규 변경, 새로운 산업 추가 등에 대한 빠른 대응

---

## 2. 공통 인프라 설계

### 2.1 공통 데이터 모델

#### 기업 기본정보 (Company Profile)
```json
{
  "company_id": "string",
  "company_name": "string",
  "industry": "string",
  "industry_code": "string",
  "listing_status": "listed|unlisted",
  "fiscal_year_end": "MM-DD",
  "establishment_date": "YYYY-MM-DD",
  "capital_structure": {
    "common_shares": "integer",
    "preferred_shares": "integer",
    "treasury_shares": "integer"
  }
}
```

#### 재무제표 (Financial Statements)
```json
{
  "statement_id": "string",
  "company_id": "string",
  "fiscal_year": "integer",
  "statement_type": "IS|BS|CF",
  "audit_status": "audited|reviewed|compiled",
  "items": [
    {
      "account_code": "string",
      "account_name": "string",
      "amount": "decimal",
      "currency": "KRW|USD"
    }
  ]
}
```

### 2.2 공통 계산 라이브러리

#### FinancialMath 라이브러리
- **현재가치 계산**: `PV(cash_flows, discount_rate, periods)`
- **미래가치 계산**: `FV(present_value, growth_rate, periods)`
- **IRR 계산**: `IRR(cash_flows, initial_guess)`
- **XIRR 계산**: `XIRR(cash_flows, dates)`
- **영구가치 계산**: `TerminalValue(fcf, growth_rate, discount_rate)`
- **회귀분석**: `LinearRegression(x, y)`
- **표준편차/분산**: `StdDev(data)`, `Variance(data)`

#### ValidationLibrary 라이브러리
- **재무제표 검증**: 대차대조표 균형 확인
- **논리적 일관성 검증**: 음수 불가 항목, 비율 범위 확인
- **Cross-check**: 손익계산서 ↔ 현금흐름표 정합성
- **Sanity Check**: 업계 평균 대비 이상치 탐지

### 2.3 공통 데이터 소스

| 데이터 유형 | 출처 | 업데이트 주기 | API/파일 |
|-----------|------|-------------|---------|
| 상장주식 시세 | KRX, Yahoo Finance | 실시간/일별 | API |
| 재무제표 (상장) | DART, KRX | 분기 | API |
| 무위험이자율 | 한국은행, 금융투자협회 | 일별 | API |
| 공시지가 | 국토교통부 | 연간 | 파일 |
| 업종별 베타 | Bloomberg, 증권사 리서치 | 월별 | 파일 |
| 거시경제지표 | 한국은행, 통계청 | 월별 | API |
| 법인세율, 세무규정 | 국세청 | 법 개정 시 | 수동 |

---

## 3. 평가법별 엔진 설계

---

## 3.1 DCF 평가법 엔진

### 3.1.1 계산 엔진 구조

#### 입력 데이터
```json
{
  "valuation_id": "DCF_20250101_001",
  "company_id": "C12345",
  "valuation_date": "2025-01-01",
  "historical_financials": {
    "years": [2022, 2023, 2024],
    "income_statements": [...],
    "balance_sheets": [...],
    "cash_flow_statements": [...]
  },
  "projection_assumptions": {
    "projection_period": 5,
    "revenue_growth_rates": [0.12, 0.10, 0.08, 0.06, 0.05],
    "operating_margin_target": 0.15,
    "capex_rate": 0.05,
    "working_capital_rate": 0.10,
    "terminal_growth_rate": 0.03
  },
  "discount_rate_inputs": {
    "risk_free_rate": 0.035,
    "market_risk_premium": 0.07,
    "beta": 1.2,
    "debt_ratio": 0.30,
    "cost_of_debt": 0.05,
    "tax_rate": 0.25
  }
}
```

#### 계산 프로세스 (6단계)

**Step 1: 과거 실적 분석 및 정규화**
```python
def normalize_historical_financials(raw_financials):
    """
    - 일회성 손익 제거
    - 재무구조 개편 효과 조정
    - 회계기준 변경 영향 제거
    - 정상화된 EBIT, NOPAT, FCF 산출
    """
    normalized = {
        "avg_revenue_growth": calculate_cagr(revenues),
        "avg_operating_margin": mean(ebit / revenue),
        "normalized_fcf": adjust_for_oneoffs(fcf),
        "avg_working_capital_ratio": mean(wc / revenue)
    }
    return normalized
```

**Step 2: 재무제표 예측**
```python
def project_financials(base_year, assumptions, periods=5):
    """
    - 매출액 예측 (성장률 적용)
    - 영업비용 예측 (목표 마진 적용)
    - CAPEX 예측 (매출액 대비 비율)
    - 운전자본 증감 예측
    """
    projections = []
    for year in range(1, periods + 1):
        proj_revenue = base_revenue * (1 + growth_rates[year])
        proj_ebit = proj_revenue * target_margin
        proj_nopat = proj_ebit * (1 - tax_rate)
        proj_capex = proj_revenue * capex_rate
        proj_wc_change = (proj_revenue - prev_revenue) * wc_rate
        proj_fcf = proj_nopat + depreciation - proj_capex - proj_wc_change
        projections.append({
            "year": base_year + year,
            "revenue": proj_revenue,
            "fcf": proj_fcf
        })
    return projections
```

**Step 3: 할인율 (WACC) 산정**
```python
def calculate_wacc(risk_free, beta, mrp, cost_debt, debt_ratio, tax_rate):
    """
    WACC = (E/V) × Re + (D/V) × Rd × (1 - T)
    Re = Rf + β × MRP
    """
    cost_equity = risk_free + beta * mrp
    equity_ratio = 1 - debt_ratio
    wacc = (equity_ratio * cost_equity) +
           (debt_ratio * cost_debt * (1 - tax_rate))
    return wacc
```

**Step 4: 현재가치 할인**
```python
def discount_cash_flows(fcf_projections, wacc):
    """
    PV(FCF) = Σ [FCFt / (1 + WACC)^t]
    """
    pv_fcf_list = []
    for t, fcf in enumerate(fcf_projections, start=1):
        pv = fcf / ((1 + wacc) ** t)
        pv_fcf_list.append(pv)
    total_pv_fcf = sum(pv_fcf_list)
    return total_pv_fcf, pv_fcf_list
```

**Step 5: 영구가치 (Terminal Value) 계산**
```python
def calculate_terminal_value(last_fcf, g_terminal, wacc, last_year):
    """
    TV = FCF_n+1 / (WACC - g)
    FCF_n+1 = FCF_n × (1 + g)
    PV(TV) = TV / (1 + WACC)^n
    """
    fcf_terminal = last_fcf * (1 + g_terminal)
    terminal_value = fcf_terminal / (wacc - g_terminal)
    pv_terminal_value = terminal_value / ((1 + wacc) ** last_year)
    return pv_terminal_value, terminal_value
```

**Step 6: 기업가치 및 주당가치 산출**
```python
def calculate_equity_value(pv_fcf, pv_tv, net_debt, non_op_assets, shares):
    """
    기업가치 = PV(FCF) + PV(TV)
    주주가치 = 기업가치 - 순부채 + 비영업자산
    주당가치 = 주주가치 / 발행주식수
    """
    enterprise_value = pv_fcf + pv_tv
    equity_value = enterprise_value - net_debt + non_op_assets
    value_per_share = equity_value / shares
    return {
        "enterprise_value": enterprise_value,
        "equity_value": equity_value,
        "value_per_share": value_per_share
    }
```

#### 출력 데이터
```json
{
  "valuation_id": "DCF_20250101_001",
  "result_summary": {
    "enterprise_value": 500000000000,
    "equity_value": 480000000000,
    "value_per_share": 48000,
    "wacc": 0.095,
    "terminal_value_percentage": 0.68
  },
  "detailed_projections": [
    {
      "year": 2025,
      "revenue": 120000000000,
      "fcf": 15000000000,
      "pv_fcf": 13698630137
    }
  ],
  "sensitivity_analysis": {
    "wacc_range": [0.08, 0.09, 0.10, 0.11, 0.12],
    "growth_range": [0.02, 0.025, 0.03, 0.035, 0.04],
    "value_matrix": [[...]]
  }
}
```

### 3.1.2 검증 로직

- **논리적 검증**: WACC > g (영구성장률)
- **Cross-check**: 예측 재무제표 대차 균형
- **Sanity check**: 영구가치 비중 50~80% 범위
- **업계 비교**: 목표 마진, 성장률이 업계 평균 ±30% 이내

---

## 3.2 상대가치평가법 엔진

### 3.2.1 계산 엔진 구조

#### 입력 데이터
```json
{
  "valuation_id": "COMP_20250101_002",
  "target_company_id": "C12345",
  "valuation_date": "2025-01-01",
  "comparable_companies": [
    {
      "comp_id": "C67890",
      "company_name": "비교기업A",
      "market_cap": 1000000000000,
      "enterprise_value": 1200000000000,
      "revenue": 500000000000,
      "ebitda": 80000000000,
      "net_income": 50000000000,
      "book_equity": 300000000000,
      "shares_outstanding": 20000000
    }
  ],
  "target_financials": {
    "revenue": 120000000000,
    "ebitda": 18000000000,
    "net_income": 10000000000,
    "book_equity": 50000000000,
    "shares_outstanding": 10000000
  }
}
```

#### 계산 프로세스 (6단계)

**Step 1: 비교기업 선정 및 검증**
```python
def select_comparable_companies(target, candidate_pool):
    """
    선정 기준:
    - 동일 산업 (KSIC 3자리 일치)
    - 유사한 규모 (매출액 50~200%)
    - 유사한 수익성 (영업이익률 차이 ±10%p)
    - 상장 여부 (시장가격 존재)
    - 최소 3개, 권장 5~10개
    """
    filtered = []
    for comp in candidate_pool:
        if (comp.industry == target.industry and
            0.5 <= comp.revenue / target.revenue <= 2.0 and
            abs(comp.op_margin - target.op_margin) <= 0.10):
            filtered.append(comp)
    return filtered[:10]
```

**Step 2: 배수 계산**
```python
def calculate_multiples(comp_financials):
    """
    계산 배수:
    - PER = 시가총액 / 당기순이익
    - PBR = 시가총액 / 순자산
    - PSR = 시가총액 / 매출액
    - EV/EBITDA = 기업가치 / EBITDA
    - EV/Sales = 기업가치 / 매출액
    """
    multiples = {
        "PER": comp_financials.market_cap / comp_financials.net_income,
        "PBR": comp_financials.market_cap / comp_financials.book_equity,
        "PSR": comp_financials.market_cap / comp_financials.revenue,
        "EV_EBITDA": comp_financials.ev / comp_financials.ebitda,
        "EV_Sales": comp_financials.ev / comp_financials.revenue
    }
    return multiples
```

**Step 3: 이상치 제거 및 대표값 산출**
```python
def calculate_representative_multiple(multiples_list, method="median"):
    """
    이상치 제거: IQR 방식 또는 Z-score
    대표값: 중앙값(median), 평균(mean), 조화평균(harmonic)
    """
    # IQR 이상치 제거
    q1 = percentile(multiples_list, 25)
    q3 = percentile(multiples_list, 75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    filtered = [m for m in multiples_list if lower_bound <= m <= upper_bound]

    # 대표값 계산
    if method == "median":
        return median(filtered)
    elif method == "mean":
        return mean(filtered)
    elif method == "harmonic":
        return len(filtered) / sum(1/m for m in filtered)
```

**Step 4: 대상기업 가치 산출**
```python
def apply_multiples_to_target(target_financials, repr_multiples):
    """
    각 배수별 가치 산출:
    - PER 방식: 순이익 × PER
    - PBR 방식: 순자산 × PBR
    - PSR 방식: 매출액 × PSR
    - EV/EBITDA 방식: EBITDA × EV/EBITDA
    """
    valuations = {
        "PER_valuation": target_financials.net_income * repr_multiples.PER,
        "PBR_valuation": target_financials.book_equity * repr_multiples.PBR,
        "PSR_valuation": target_financials.revenue * repr_multiples.PSR,
        "EV_EBITDA_valuation": (target_financials.ebitda * repr_multiples.EV_EBITDA) - net_debt
    }
    return valuations
```

**Step 5: 할인/할증 조정**
```python
def apply_adjustments(base_valuation, adjustments):
    """
    조정 요인:
    - 규모 할인 (소형주): -10% ~ -20%
    - 유동성 할인 (비상장): -20% ~ -40%
    - 지배주주 할증: +15% ~ +30%
    - 성장성 프리미엄: +10% ~ +20%
    """
    adjusted_value = base_valuation
    for adj_type, adj_rate in adjustments.items():
        adjusted_value *= (1 + adj_rate)
    return adjusted_value
```

**Step 6: 최종 가치 산출 (가중평균)**
```python
def weighted_average_valuation(valuations, weights):
    """
    배수별 신뢰도에 따른 가중평균
    예: PER 30%, EV/EBITDA 40%, PBR 20%, PSR 10%
    """
    final_value = sum(val * weight for val, weight in zip(valuations.values(), weights.values()))
    value_per_share = final_value / target_shares
    return final_value, value_per_share
```

#### 출력 데이터
```json
{
  "valuation_id": "COMP_20250101_002",
  "comparable_summary": {
    "num_comparables": 7,
    "median_multiples": {
      "PER": 12.5,
      "PBR": 1.8,
      "EV_EBITDA": 8.2
    }
  },
  "valuation_by_multiple": {
    "PER_valuation": 125000000000,
    "PBR_valuation": 90000000000,
    "EV_EBITDA_valuation": 140000000000
  },
  "final_valuation": {
    "equity_value": 120000000000,
    "value_per_share": 12000
  }
}
```

### 3.2.2 검증 로직

- **비교기업 적합성**: 산업, 규모, 수익성 유사도 점수 70점 이상
- **배수 분포**: 표준편차 / 평균 < 0.5 (안정성 확인)
- **Cross-check**: 여러 배수 간 가치 편차 ±30% 이내

---

## 3.3 자산가치평가법 엔진

### 3.3.1 계산 엔진 구조

#### 입력 데이터
```json
{
  "valuation_id": "NAV_20250101_003",
  "company_id": "C12345",
  "valuation_date": "2025-01-01",
  "balance_sheet": {
    "assets": {
      "land": {"book_value": 8000000000, "appraisal_value": 20000000000},
      "buildings": {"book_value": 5000000000, "replacement_cost": 6000000000, "age": 20, "useful_life": 50},
      "machinery": {"book_value": 3000000000, "market_value": 2000000000},
      "inventory": {"book_value": 4000000000, "nrv": 3800000000},
      "receivables": {"book_value": 3000000000, "bad_debt": 200000000},
      "listed_stocks": {"book_value": 2000000000, "market_value": 3500000000},
      "cash": 5000000000
    },
    "liabilities": {
      "short_term_debt": 5000000000,
      "long_term_debt": {"book_value": 7000000000, "market_rate": 0.07, "contract_rate": 0.05, "maturity": 5},
      "accounts_payable": 3000000000,
      "contingent_liabilities": {"lawsuit_amount": 5000000000, "probability": 0.4}
    }
  },
  "shares_outstanding": 10000000
}
```

#### 계산 프로세스 (6단계)

**Step 1: 재무상태표 확보 및 기초 분석**
```python
def analyze_balance_sheet(balance_sheet):
    """
    - 자산 구성 분석 (유형자산, 무형자산, 금융자산)
    - 부채 구조 분석
    - 주석 사항 검토 (우발부채, 담보, 특수관계자)
    """
    analysis = {
        "tangible_asset_ratio": sum(tangible_assets) / total_assets,
        "financial_asset_ratio": sum(financial_assets) / total_assets,
        "debt_ratio": total_liabilities / total_assets
    }
    return analysis
```

**Step 2: 자산 항목별 시장가치 재평가**
```python
def revalue_assets(assets):
    """
    자산별 평가 방법:
    - 토지: 감정평가 > 실거래가 > 공시지가×할증률
    - 건물: 재조달원가 - 감가상각
    - 기계: 중고시장 가격 or 재조달원가×(1-감가상각률)^년수
    - 재고: 순실현가능가치 (NRV)
    - 매출채권: 장부가액 - 대손추산액
    - 상장주식: 평가기준일 시가
    - 비상장주식: 별도 평가 필요
    """
    revalued = {}

    # 토지
    revalued["land"] = assets.land.appraisal_value if assets.land.appraisal_value else \
                       estimate_land_value(assets.land.public_price)

    # 건물
    depreciation = assets.buildings.replacement_cost * (assets.buildings.age / assets.buildings.useful_life)
    revalued["buildings"] = assets.buildings.replacement_cost - depreciation

    # 기계
    revalued["machinery"] = assets.machinery.market_value

    # 재고
    revalued["inventory"] = assets.inventory.nrv

    # 매출채권
    revalued["receivables"] = assets.receivables.book_value - assets.receivables.bad_debt

    # 상장주식
    revalued["listed_stocks"] = assets.listed_stocks.market_value

    # 현금
    revalued["cash"] = assets.cash

    total_revalued_assets = sum(revalued.values())
    return revalued, total_revalued_assets
```

**Step 3: 부채 항목별 시장가치 재평가**
```python
def revalue_liabilities(liabilities, market_rate):
    """
    부채별 평가:
    - 단기부채: 장부가액 = 시장가치
    - 장기부채: 원리금의 현재가치
    - 우발부채: 예상금액 × 발생확률
    """
    revalued = {}

    # 단기부채
    revalued["short_term_debt"] = liabilities.short_term_debt
    revalued["accounts_payable"] = liabilities.accounts_payable

    # 장기부채 현재가치
    annual_interest = liabilities.long_term_debt.book_value * liabilities.long_term_debt.contract_rate
    pv_debt = 0
    for t in range(1, liabilities.long_term_debt.maturity + 1):
        if t < liabilities.long_term_debt.maturity:
            cf = annual_interest
        else:
            cf = annual_interest + liabilities.long_term_debt.book_value
        pv_debt += cf / ((1 + market_rate) ** t)
    revalued["long_term_debt"] = pv_debt

    # 우발부채
    revalued["contingent_liabilities"] = liabilities.contingent_liabilities.lawsuit_amount * \
                                         liabilities.contingent_liabilities.probability

    total_revalued_liabilities = sum(revalued.values())
    return revalued, total_revalued_liabilities
```

**Step 4: 우발부채 및 비계상 항목 반영**
```python
def identify_off_balance_items(notes):
    """
    - 계류 중 소송
    - 보증채무
    - 환경복구 의무
    - 퇴직급여 미적립분
    """
    off_balance_liabilities = 0
    for item in notes.contingent_items:
        expected_liability = item.amount * item.probability
        off_balance_liabilities += expected_liability
    return off_balance_liabilities
```

**Step 5: 비영업자산 식별 및 분리**
```python
def identify_non_operating_assets(assets):
    """
    비영업자산:
    - 투자부동산 (임대용)
    - 유휴 토지
    - 단기매매 금융자산
    - 특수관계자 대여금
    """
    non_op_assets = {
        "investment_property": assets.investment_property,
        "idle_land": assets.idle_land,
        "trading_securities": assets.trading_securities,
        "related_party_loans": assets.related_party_loans
    }
    total_non_op = sum(non_op_assets.values())
    return non_op_assets, total_non_op
```

**Step 6: 순자산가치 및 주당가치 산출**
```python
def calculate_nav(revalued_assets, revalued_liabilities, shares):
    """
    NAV = 자산 시가 - 부채 시가
    주당 NAV = NAV / 발행주식수
    """
    nav = revalued_assets - revalued_liabilities
    nav_per_share = nav / shares

    # 청산가치 (할인율 적용)
    liquidation_value = apply_liquidation_discount(revalued_assets) - revalued_liabilities
    liquidation_per_share = liquidation_value / shares

    return {
        "nav": nav,
        "nav_per_share": nav_per_share,
        "liquidation_value": liquidation_value,
        "liquidation_per_share": liquidation_per_share,
        "going_concern_premium": nav - liquidation_value
    }
```

#### 출력 데이터
```json
{
  "valuation_id": "NAV_20250101_003",
  "asset_revaluation_summary": {
    "book_value": 30000000000,
    "market_value": 43100000000,
    "adjustment": 13100000000
  },
  "liability_revaluation_summary": {
    "book_value": 15000000000,
    "market_value": 15500000000,
    "adjustment": 500000000
  },
  "nav_result": {
    "net_asset_value": 27600000000,
    "nav_per_share": 27600,
    "liquidation_value": 13000000000,
    "liquidation_per_share": 13000
  }
}
```

### 3.3.2 검증 로직

- **대차 균형**: 조정 후 자산 = 조정 후 부채 + 순자산
- **감정평가 유효성**: 6개월 이내 자료 확인
- **청산가치 < 계속기업가치**: 논리적 타당성 검증

---

## 3.4 자본시장법평가법 엔진

### 3.4.1 계산 엔진 구조

#### 입력 데이터
```json
{
  "valuation_id": "FSCMA_20250101_004",
  "company_id": "C12345",
  "valuation_date": "2025-01-01",
  "purpose": "merger|split|stock_swap",
  "historical_financials": {
    "years": [2022, 2023, 2024],
    "net_income": [8000000000, 10000000000, 12000000000],
    "revenue": [100000000000, 110000000000, 120000000000]
  },
  "balance_sheet": {
    "total_assets": 150000000000,
    "total_liabilities": 55000000000,
    "book_equity": 95000000000
  },
  "shares_outstanding": 10000000,
  "discount_rate": 0.10
}
```

#### 계산 프로세스 (6단계)

**Step 1: 재무제표 확보 및 적격성 검토**
```python
def validate_financial_statements(financials):
    """
    - 외부감사 필수
    - 3개년 연속 재무제표 존재
    - 감사의견: 적정 or 한정 (부적정/의견거절 배제)
    """
    if not financials.audited:
        raise ValueError("외부감사 재무제표 필요")
    if len(financials.years) < 3:
        raise ValueError("최소 3개년 재무제표 필요")
    return True
```

**Step 2: 1주당 수익가치 계산**
```python
def calculate_earning_value(net_incomes, shares, discount_rate, method="weighted_avg"):
    """
    가중평균 방식:
    최근 3년 순이익에 가중치 (3:2:1 또는 5:3:2)

    1주당 수익가치 = 1주당 가중평균 순이익 / 할인율
    """
    if method == "weighted_avg":
        # 최근년도부터 3, 2, 1 가중치
        weights = [3, 2, 1]
        weighted_income = sum(income * weight for income, weight in zip(reversed(net_incomes), weights))
        avg_income = weighted_income / sum(weights)
    elif method == "simple_avg":
        avg_income = mean(net_incomes)

    earning_per_share = avg_income / shares
    earning_value_per_share = earning_per_share / discount_rate

    return earning_value_per_share, earning_per_share
```

**Step 3: 1주당 자산가치 계산**
```python
def calculate_asset_value(balance_sheet, shares):
    """
    1주당 자산가치 = (자산 시가 - 부채 시가) / 발행주식수

    시가 평가:
    - 토지: 감정평가 or 공시지가
    - 유가증권: 시장가격
    - 기타: 장부가액 (간편법) or 개별 재평가
    """
    # 간편법: 장부가액 사용
    book_equity = balance_sheet.total_assets - balance_sheet.total_liabilities

    # 또는 자산 재평가 (자산가치평가법 엔진 활용)
    revalued_assets = revalue_major_assets(balance_sheet.assets)
    revalued_liabilities = balance_sheet.total_liabilities

    net_asset_value = revalued_assets - revalued_liabilities
    asset_value_per_share = net_asset_value / shares

    return asset_value_per_share
```

**Step 4: 가중평균 산정 (1.5 : 1)**
```python
def calculate_weighted_value(earning_value, asset_value):
    """
    자본시장법 평가액 = (수익가치 × 1.5 + 자산가치 × 1) / 2.5

    또는
    = 수익가치 × 60% + 자산가치 × 40%
    """
    weighted_value = (earning_value * 1.5 + asset_value * 1.0) / 2.5

    # 검증
    alternative = earning_value * 0.6 + asset_value * 0.4
    assert abs(weighted_value - alternative) < 0.01

    return weighted_value
```

**Step 5: 할인/할증 사유 반영**
```python
def apply_adjustments(base_value, adjustments):
    """
    할증 사유:
    - 우량 자산 보유 (+5~10%)
    - 높은 성장성 (+10~15%)
    - 독점적 기술 (+10~20%)

    할인 사유:
    - 소수지분 (-10~20%)
    - 유동성 부족 (-15~25%)
    - 경영 불안정 (-10~15%)
    """
    adjusted_value = base_value
    for reason, rate in adjustments.items():
        adjusted_value *= (1 + rate)
    return adjusted_value
```

**Step 6: 최종 평가액 산출**
```python
def finalize_valuation(weighted_value_per_share, shares, adjustments):
    """
    주당 평가액 = 가중평균 가치 × (1 ± 할인/할증률)
    총 평가액 = 주당 평가액 × 발행주식수
    """
    adjusted_per_share = apply_adjustments(weighted_value_per_share, adjustments)
    total_valuation = adjusted_per_share * shares

    return {
        "value_per_share": adjusted_per_share,
        "total_valuation": total_valuation
    }
```

#### 출력 데이터
```json
{
  "valuation_id": "FSCMA_20250101_004",
  "earning_value_per_share": 100000,
  "asset_value_per_share": 95000,
  "weighted_value_per_share": 98000,
  "adjustments": {
    "growth_premium": 0.10
  },
  "final_value_per_share": 107800,
  "total_valuation": 1078000000000
}
```

### 3.4.2 검증 로직

- **가중평균 검증**: (수익×1.5 + 자산×1) / 2.5 = 수익×60% + 자산×40%
- **할인율 적정성**: 8~12% 범위 (시장금리 고려)
- **할인/할증률 합리성**: 총 조정 범위 ±30% 이내

---

## 3.5 상증세법평가법 엔진

### 3.5.1 계산 엔진 구조

#### 입력 데이터
```json
{
  "valuation_id": "ITAX_20250101_005",
  "company_id": "C12345",
  "valuation_date": "2025-12-31",
  "purpose": "inheritance|gift",
  "shareholder_type": "majority|minority",
  "shareholding_ratio": 0.40,
  "historical_financials": {
    "years": [2022, 2023, 2024],
    "tax_adjusted_income": [1100000000, 2200000000, 2500000000]
  },
  "balance_sheet": {
    "assets": {
      "land": {"book": 5000000000, "public_price": 8000000000},
      "buildings": {"book": 3000000000, "standard_price": 3500000000},
      "listed_stocks": {"book": 2000000000, "market_avg_2m": 2500000000},
      "other_assets": 14000000000
    },
    "liabilities": {
      "debt": 5000000000,
      "contingent": 1000000000
    }
  },
  "shares_outstanding": 1000000,
  "discount_rate": 0.10
}
```

#### 계산 프로세스 (6단계)

**Step 1: 재무제표 수집 및 기준일 설정**
```python
def collect_tax_data(company_id, valuation_date):
    """
    - 평가기준일 직전 3개 사업연도
    - 법인세 신고서 (세무조정계산서)
    - 재무상태표 (평가기준일 현재)
    """
    base_year = valuation_date.year
    years = [base_year - 2, base_year - 1, base_year]

    financials = fetch_tax_returns(company_id, years)
    balance_sheet = fetch_balance_sheet(company_id, valuation_date)

    return financials, balance_sheet
```

**Step 2: 순손익가치 계산 (세무조정 포함)**
```python
def calculate_net_income_value(tax_adjusted_incomes, shares, discount_rate):
    """
    1. 3년 평균 순손익 = (N-2년 + N-1년 + N년) / 3
    2. 1주당 순손익액 = 평균 순손익 / 발행주식수
    3. 1주당 순손익가치 = 1주당 순손익액 / 할인율 (10%)

    주의: 단순산술평균 (가중평균 아님)
    """
    # 세무조정 및 일회성 손익 제거 (별도 함수)
    adjusted_incomes = [remove_one_time_items(income) for income in tax_adjusted_incomes]

    # 3년 평균
    avg_income = sum(adjusted_incomes) / 3

    # 1주당 순손익
    income_per_share = avg_income / shares

    # 순손익가치
    income_value_per_share = income_per_share / discount_rate

    return income_value_per_share, avg_income, income_per_share
```

**Step 3: 순자산가치 계산 (시가 재평가)**
```python
def calculate_net_asset_value(balance_sheet, shares):
    """
    자산 시가 평가:
    - 토지: 개별공시지가 (현실화율 고려)
    - 건물: 국세청 기준시가
    - 상장주식: 평가기준일 전후 2개월 평균 종가
    - 비상장주식: 재귀적 상증세법 평가
    - 기타: 장부가액 또는 시가

    부채 시가 평가:
    - 단기부채: 장부가액
    - 장기부채: 현재가치
    - 우발부채: 발생가능금액
    """
    # 자산 재평가
    revalued_land = balance_sheet.assets.land.public_price / 0.70 * 1.4  # 공시지가 → 시가 추정
    revalued_buildings = balance_sheet.assets.buildings.standard_price
    revalued_stocks = balance_sheet.assets.listed_stocks.market_avg_2m
    other_assets = balance_sheet.assets.other_assets

    total_assets = revalued_land + revalued_buildings + revalued_stocks + other_assets

    # 부채 재평가
    total_liabilities = balance_sheet.liabilities.debt + balance_sheet.liabilities.contingent

    # 순자산
    net_assets = total_assets - total_liabilities
    asset_value_per_share = net_assets / shares

    return asset_value_per_share, net_assets
```

**Step 4: 1주당 평가액 산출 (가중평균 3:2)**
```python
def calculate_weighted_average(income_value, asset_value):
    """
    평가액 = (순손익가치 × 3 + 순자산가치 × 2) / 5

    또는
    = 순손익가치 × 60% + 순자산가치 × 40%
    """
    weighted_value = (income_value * 3 + asset_value * 2) / 5

    # 검증
    alternative = income_value * 0.6 + asset_value * 0.4
    assert abs(weighted_value - alternative) < 0.01

    return weighted_value
```

**Step 5: 할인/할증 적용**
```python
def apply_premium_discount(base_value, shareholder_type, shareholding_ratio):
    """
    할증 (최대주주):
    - 지분율 > 50% or 최대주주: +20%

    할인 (소액주주):
    - 지분율 < 3%: -20%
    - 시가총액 < 15억원: -20%
    """
    if shareholder_type == "majority":
        adjusted_value = base_value * 1.20
    elif shareholding_ratio < 0.03:
        adjusted_value = base_value * 0.80
    else:
        adjusted_value = base_value

    return adjusted_value
```

**Step 6: 최종 평가액 산출 및 세액 계산**
```python
def calculate_tax(valuation_per_share, shares, purpose):
    """
    총 평가액 = 주당 평가액 × 보유주식수

    증여세:
    - 과세표준 = 총 평가액 - 증여재산공제
    - 세율: 10~50% (누진)

    상속세:
    - 과세표준 = 총 상속재산 - 공제
    - 세율: 10~50% (누진)
    """
    total_valuation = valuation_per_share * shares

    if purpose == "gift":
        deduction = 50000000  # 직계존속 5천만원
        taxable = max(0, total_valuation - deduction)
        tax = calculate_progressive_tax(taxable, gift_tax_schedule)
    elif purpose == "inheritance":
        deduction = 500000000  # 일괄공제 5억원
        taxable = max(0, total_valuation - deduction)
        tax = calculate_progressive_tax(taxable, inheritance_tax_schedule)

    return {
        "total_valuation": total_valuation,
        "taxable_amount": taxable,
        "tax_amount": tax
    }
```

#### 출력 데이터
```json
{
  "valuation_id": "ITAX_20250101_005",
  "income_value_per_share": 19330,
  "asset_value_per_share": 13400,
  "base_value_per_share": 16958,
  "adjusted_value_per_share": 20350,
  "adjustment_type": "majority_premium_20%",
  "total_valuation": 8140000000,
  "tax_calculation": {
    "taxable_amount": 7640000000,
    "tax_rate": "40%",
    "tax_amount": 2856000000
  }
}
```

### 3.5.2 검증 로직

- **세무조정 완료 확인**: 법인세 신고서 기준
- **할인율 확인**: 현행 10% (국세청 고시)
- **할인/할증 상호 배타**: 동시 적용 불가
- **가중평균 검증**: (순손익×3 + 순자산×2) / 5

---

## 4. 보고서 작성 엔진 설계

### 4.1 보고서 구조 표준화

#### 공통 목차 (5대 평가법 공통)

```
1. 평가 개요
   1.1 평가 목적 및 기준일
   1.2 평가 대상 기업 개요
   1.3 평가 방법론 선택 근거

2. 기업 및 산업 분석
   2.1 사업 개요 및 비즈니스 모델
   2.2 산업 환경 분석
   2.3 경쟁 구조 및 시장 지위
   2.4 재무 현황 분석 (과거 3~5년)

3. 평가 방법론 및 가정 사항
   3.1 적용 평가법 설명
   3.2 주요 가정 및 변수
   3.3 데이터 출처

4. 평가 계산 과정
   4.1 단계별 계산 상세
   4.2 중간 결과물
   4.3 민감도 분석

5. 평가 결과
   5.1 주당 가치
   5.2 총 기업가치
   5.3 평가 범위 (최소~최대)

6. 결론 및 유의사항
   6.1 평가 요약
   6.2 제한 사항
   6.3 추가 고려사항

부록
   A. 재무제표
   B. 세부 계산표
   C. 참고자료
```

### 4.2 템플릿 엔진 구조

#### 템플릿 시스템
```python
class ReportTemplateEngine:
    """
    Jinja2 기반 템플릿 엔진
    - HTML/PDF/DOCX 출력 지원
    - 다국어 지원 (한국어, 영어)
    - 차트/그래프 자동 생성
    """

    def __init__(self, template_dir):
        self.env = jinja2.Environment(loader=FileSystemLoader(template_dir))
        self.chart_generator = ChartGenerator()

    def render_report(self, valuation_result, template_name, output_format):
        """
        평가 결과를 보고서로 변환
        """
        # 템플릿 로드
        template = self.env.get_template(f"{template_name}.html")

        # 차트 생성
        charts = self.generate_charts(valuation_result)

        # 데이터 렌더링
        html_content = template.render(
            result=valuation_result,
            charts=charts,
            generated_date=datetime.now()
        )

        # 포맷 변환
        if output_format == "pdf":
            return self.html_to_pdf(html_content)
        elif output_format == "docx":
            return self.html_to_docx(html_content)
        else:
            return html_content

    def generate_charts(self, result):
        """
        차트 자동 생성:
        - DCF: 현금흐름 차트, 민감도 분석 히트맵
        - 상대가치: 배수 분포 박스플롯, 비교기업 산점도
        - 자산가치: 자산/부채 조정 워터폴 차트
        """
        charts = {}

        if result.method == "DCF":
            charts["fcf_chart"] = self.chart_generator.create_fcf_chart(result.fcf_projections)
            charts["sensitivity"] = self.chart_generator.create_heatmap(result.sensitivity_analysis)
        elif result.method == "Comparable":
            charts["multiples_dist"] = self.chart_generator.create_boxplot(result.comparables_multiples)
        # ... 기타 평가법

        return charts
```

### 4.3 차트 및 시각화 자동 생성

#### Chart Generator
```python
class ChartGenerator:
    """
    Matplotlib/Plotly 기반 차트 생성
    """

    def create_fcf_chart(self, fcf_projections):
        """
        FCF 예측 막대 그래프
        """
        years = [p['year'] for p in fcf_projections]
        fcf_values = [p['fcf'] / 1e9 for p in fcf_projections]  # 억원 단위

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(years, fcf_values, color='steelblue')
        ax.set_xlabel('연도')
        ax.set_ylabel('FCF (억원)')
        ax.set_title('연도별 잉여현금흐름 예측')

        return fig_to_base64(fig)

    def create_heatmap(self, sensitivity_matrix):
        """
        민감도 분석 히트맵
        """
        import seaborn as sns

        fig, ax = plt.subplots(figsize=(10, 8))
        sns.heatmap(sensitivity_matrix, annot=True, fmt=".0f", cmap="RdYlGn", ax=ax)
        ax.set_xlabel('영구성장률 (%)')
        ax.set_ylabel('WACC (%)')
        ax.set_title('주당가치 민감도 분석 (원)')

        return fig_to_base64(fig)

    def create_waterfall_chart(self, adjustments):
        """
        자산/부채 조정 워터폴 차트
        """
        categories = ['장부가액', '토지 재평가', '건물 조정', '부채 조정', '시가 순자산']
        values = adjustments

        # Plotly waterfall chart
        fig = go.Figure(go.Waterfall(
            x=categories,
            y=values,
            connector={"line": {"color": "rgb(63, 63, 63)"}}
        ))

        return fig.to_html(include_plotlyjs=False)
```

### 4.4 Excel 출력 엔진

```python
class ExcelReportGenerator:
    """
    openpyxl 기반 Excel 보고서 생성
    """

    def generate_dcf_workbook(self, valuation_result):
        """
        DCF 평가 Excel 파일 생성
        - Sheet 1: 요약
        - Sheet 2: 재무제표 예측
        - Sheet 3: FCF 계산
        - Sheet 4: WACC 계산
        - Sheet 5: 민감도 분석
        """
        wb = openpyxl.Workbook()

        # Sheet 1: 요약
        ws_summary = wb.active
        ws_summary.title = "평가 요약"
        self.write_summary(ws_summary, valuation_result)

        # Sheet 2: 재무제표 예측
        ws_projections = wb.create_sheet("재무제표 예측")
        self.write_projections(ws_projections, valuation_result.projections)

        # Sheet 3: FCF 계산
        ws_fcf = wb.create_sheet("FCF 계산")
        self.write_fcf_calculation(ws_fcf, valuation_result.fcf_details)

        # ... 기타 시트

        return wb

    def write_summary(self, ws, result):
        """
        요약 시트 작성
        """
        ws['A1'] = '기업가치평가 보고서'
        ws['A1'].font = Font(size=16, bold=True)

        ws['A3'] = '평가 대상'
        ws['B3'] = result.company_name

        ws['A4'] = '평가 기준일'
        ws['B4'] = result.valuation_date

        ws['A6'] = '평가 결과'
        ws['A7'] = '기업가치'
        ws['B7'] = result.enterprise_value
        ws['B7'].number_format = '#,##0'

        ws['A8'] = '주주가치'
        ws['B8'] = result.equity_value
        ws['B8'].number_format = '#,##0'

        ws['A9'] = '주당가치'
        ws['B9'] = result.value_per_share
        ws['B9'].number_format = '#,##0'
```

### 4.5 PDF 생성 엔진

```python
class PDFReportGenerator:
    """
    WeasyPrint 또는 ReportLab 기반 PDF 생성
    """

    def generate_pdf(self, html_content, css_path):
        """
        HTML → PDF 변환
        """
        from weasyprint import HTML, CSS

        pdf_bytes = HTML(string=html_content).write_pdf(
            stylesheets=[CSS(filename=css_path)]
        )

        return pdf_bytes

    def add_watermark(self, pdf_bytes, watermark_text):
        """
        워터마크 추가 (초안, 기밀 등)
        """
        # PyPDF2 또는 reportlab 사용
        pass
```

---

## 5. 데이터 요구사항

### 5.1 필수 데이터 소스

| 데이터 종류 | 출처 | 형식 | 업데이트 주기 | 비고 |
|-----------|------|------|-------------|------|
| **재무제표 (상장)** | DART, KRX | JSON/XML | 분기 | API 연동 |
| **재무제표 (비상장)** | 사용자 입력 | Excel/CSV | 수동 | 검증 필수 |
| **주가 데이터** | KRX, Yahoo Finance | JSON | 실시간/일별 | API |
| **무위험이자율** | 한국은행 | JSON | 일별 | 3년/5년/10년 국고채 |
| **시장위험프리미엄** | 증권사 리서치 | 수동 | 연간 | 5~8% 범위 |
| **업종별 베타** | Bloomberg, FnGuide | Excel | 월별 | 산업별 평균 |
| **공시지가** | 국토교통부 | 파일(대용량) | 연간 | 부동산 평가용 |
| **비교기업 재무** | FnGuide, WISEfn | API | 분기 | 상대가치평가용 |
| **환율** | 한국은행 | JSON | 일별 | 글로벌 기업 평가 |
| **법인세율** | 국세청 | 수동 | 법 개정 시 | 10~25% |

### 5.2 데이터 품질 관리

#### 검증 체크리스트
- [ ] **완전성**: 필수 항목 누락 없음
- [ ] **정확성**: 대차대조표 균형, 논리적 일관성
- [ ] **적시성**: 최신 데이터 사용 (6개월 이내)
- [ ] **일관성**: 동일 항목 연도별 일관성
- [ ] **출처 신뢰성**: 공식 출처 또는 감사받은 자료

#### 데이터 정제 프로세스
```python
def clean_financial_data(raw_data):
    """
    1. 결측치 처리 (보간, 평균 대체)
    2. 이상치 탐지 및 조정
    3. 단위 통일 (원, 억원, 조원)
    4. 회계기준 통일 (K-IFRS)
    """
    cleaned = raw_data.copy()

    # 결측치 처리
    cleaned.fillna(method='ffill', inplace=True)

    # 이상치 탐지 (Z-score > 3)
    z_scores = (cleaned - cleaned.mean()) / cleaned.std()
    cleaned[abs(z_scores) > 3] = cleaned.median()

    # 단위 통일
    cleaned = convert_to_krw(cleaned)

    return cleaned
```

---

## 6. 기술 스택 및 구현 방안

### 백엔드

| 레이어 | 기술 스택 | 선택 이유 |
|-------|---------|---------|
| **언어** | Python 3.10+ | 데이터 분석, 수치 계산 최적화 |
| **프레임워크** | FastAPI | 고성능 비동기 API, 자동 문서화 |
| **ORM** | SQLAlchemy | 복잡한 쿼리 및 관계 관리 |
| **비동기 처리** | Celery + Redis | 장시간 계산 작업 큐 관리 |
| **수치 계산** | NumPy, SciPy | 행렬 연산, 최적화 알고리즘 |
| **재무 계산** | pandas, QuantLib | 시계열 분석, 금융 모델링 |
| **통계 분석** | statsmodels | 회귀분석, 시계열 분석 |
| **검증** | pytest, hypothesis | 단위 테스트, 속성 기반 테스트 |

### 프론트엔드

| 레이어 | 기술 스택 | 선택 이유 |
|-------|---------|---------|
| **프레임워크** | React 18 | 컴포넌트 재사용성, 생태계 |
| **상태 관리** | Redux Toolkit | 복잡한 평가 상태 관리 |
| **UI 라이브러리** | Material-UI v5 | 전문적 디자인, 접근성 |
| **차트** | Recharts, D3.js | 인터랙티브 차트 |
| **폼 관리** | React Hook Form | 복잡한 입력 폼 검증 |
| **테이블** | AG Grid | 대용량 데이터 그리드 |

### 데이터베이스

| 용도 | 기술 스택 | 선택 이유 |
|-----|---------|---------|
| **주 데이터베이스** | PostgreSQL 15 | JSONB, 트랜잭션, 성능 |
| **캐시** | Redis | 시장 데이터 캐싱 |
| **시계열 데이터** | TimescaleDB | 주가, 재무지표 시계열 |
| **문서 저장** | MongoDB (선택) | 비정형 데이터 (주석, 리포트) |

### 인프라

| 레이어 | 기술 스택 | 선택 이유 |
|-------|---------|---------|
| **컨테이너** | Docker, Docker Compose | 일관된 개발/배포 환경 |
| **오케스트레이션** | Kubernetes (선택) | 스케일링, 고가용성 |
| **CI/CD** | GitHub Actions | 자동 테스트, 배포 |
| **모니터링** | Prometheus, Grafana | 성능 모니터링 |
| **로깅** | ELK Stack | 중앙화된 로그 관리 |
| **클라우드** | AWS / GCP / Azure | 인프라 유연성 |

### 보안

- **인증/인가**: JWT, OAuth 2.0
- **데이터 암호화**: AES-256 (저장), TLS 1.3 (전송)
- **접근 제어**: RBAC (역할 기반)
- **감사 로그**: 모든 평가 작업 추적 기록
- **백업**: 일일 자동 백업, 30일 보관

---

## 7. 개발 Phase 계획

### Phase 1: 기반 구축

**목표**: 공통 인프라 및 핵심 라이브러리 구축

**주요 작업**:
- [ ] 시스템 아키텍처 설계 확정
- [ ] Database 스키마 설계 및 구축 (PostgreSQL, Redis)
- [ ] 공통 계산 라이브러리 개발
  - FinancialMath: PV, FV, IRR, XIRR, WACC, 회귀분석
  - ValidationLibrary: 재무제표 검증, 논리적 일관성 체크
  - 단위 테스트 작성 (pytest)
- [ ] 외부 API 연동 (DART, KRX, 한국은행)
- [ ] 데이터 정제 및 검증 모듈
- [ ] React 프로젝트 셋업 및 디자인 시스템
- [ ] 공통 UI 컴포넌트 (입력 폼, 테이블, 차트)
- [ ] 인증/인가 시스템 (JWT)

**완료 기준**:
- 공통 라이브러리 단위 테스트 커버리지 90% 이상
- 외부 API 데이터 수집 정상 작동
- 기본 UI 프레임워크 구축 완료

---

### Phase 2: DCF 평가법 엔진

**목표**: DCF 평가법 전체 프로세스 구현 (계산 + 보고서)

**주요 작업**:
- [ ] 입력 데이터 모델 및 API 설계
- [ ] 재무제표 정규화 로직 (일회성 손익 제거, 회계기준 통일)
- [ ] 재무제표 예측 엔진 (매출, EBIT, FCF)
- [ ] WACC 계산 엔진 (Risk-free rate, Beta, Market premium)
- [ ] 현금흐름 할인 및 현재가치 계산
- [ ] 영구가치(Terminal Value) 계산
- [ ] 기업가치 및 주당가치 산출
- [ ] 민감도 분석 (WACC, 성장률)
- [ ] DCF 입력 UI 개발 (다단계 위저드)
- [ ] 보고서 템플릿 개발 (HTML, PDF)
- [ ] 차트 생성 (FCF 막대그래프, 민감도 히트맵)
- [ ] End-to-End 테스트 및 검증

**완료 기준**:
- 실제 상장사 DCF 평가와 비교 검증 (오차 ±5% 이내)
- 보고서 자동 생성 정상 작동
- 민감도 분석 시각화 완료

---

### Phase 3: 상대가치평가법 엔진

**목표**: 비교기업 방식 평가 구현

**주요 작업**:
- [ ] 비교기업 선정 알고리즘 (산업, 규모, 수익성 기준)
- [ ] 배수 계산 엔진 (PER, PBR, PSR, EV/EBITDA, EV/Sales)
- [ ] 이상치 제거 로직 (IQR 방식, Z-score)
- [ ] 대표값 산출 (중앙값, 평균, 조화평균)
- [ ] 대상기업 가치 산출 (배수 적용)
- [ ] 할인/할증 조정 (규모, 유동성, 지배권)
- [ ] 가중평균 최종 가치 산출
- [ ] 상대가치 입력 UI (비교기업 검색 및 선택)
- [ ] 보고서 템플릿 (비교기업 테이블, 배수 분포 차트)
- [ ] 테스트 및 검증

**완료 기준**:
- 비교기업 자동 선정 정확도 80% 이상
- 배수 계산 정확성 검증 완료
- 보고서 생성 정상 작동

---

### Phase 4: 자산가치평가법 엔진

**목표**: 순자산가치(NAV) 및 청산가치 평가 구현

**주요 작업**:
- [ ] 자산 재평가 엔진
  - 토지: 감정평가, 실거래가, 공시지가 기반
  - 건물: 재조달원가 - 감가상각
  - 기계: 중고시장 가격, 재조달원가법
  - 재고: 순실현가능가치(NRV)
  - 매출채권: 회수가능액 평가
  - 상장주식: 시장가격
- [ ] 부채 재평가 엔진 (장기차입금 현재가치, 우발부채)
- [ ] NAV 계산 (자산 시가 - 부채 시가)
- [ ] 청산가치 계산 (할인율 적용)
- [ ] SOTP(Sum-of-the-Parts) 방식 구현 (지주회사 평가)
- [ ] 비영업자산 식별 및 분리
- [ ] 자산가치 입력 UI (자산/부채 항목별 입력)
- [ ] 보고서 템플릿 (워터폴 차트, 청산가치 비교)
- [ ] 테스트 및 검증

**완료 기준**:
- 부동산 감정평가액 vs 계산값 오차 ±10% 이내
- 청산가치 < 계속기업가치 논리 검증 완료
- SOTP 계산 정확성 확인

---

### Phase 5: 자본시장법/상증세법 엔진

**목표**: 법정 평가방법 2종 구현

**5A. 자본시장법 평가법 엔진**

**주요 작업**:
- [ ] 수익가치 계산 (3년 가중평균 순이익 / 할인율)
- [ ] 자산가치 계산 (자산 시가 - 부채 시가)
- [ ] 가중평균 (수익×1.5 + 자산×1) / 2.5
- [ ] 할인/할증 조정 (우량자산, 성장성, 소수지분)
- [ ] 입력 UI 및 보고서 템플릿
- [ ] 테스트

**5B. 상증세법 평가법 엔진**

**주요 작업**:
- [ ] 세무조정 로직 (손금불산입, 익금불산입, 일회성 제거)
- [ ] 순손익가치 계산 (3년 평균 / 할인율 10%)
- [ ] 순자산가치 계산 (토지: 공시지가, 건물: 기준시가, 상장주식: 2개월 평균)
- [ ] 가중평균 (순손익×3 + 순자산×2) / 5
- [ ] 할증/할인 (최대주주 +20%, 소액주주 -20%)
- [ ] 증여세/상속세 자동 계산 (누진세율표 적용)
- [ ] 입력 UI (세무조정 항목 입력 인터페이스)
- [ ] 보고서 템플릿 (세무신고용 평가서 양식)
- [ ] 테스트

**완료 기준**:
- 국세청 유권해석 사례와 비교 검증 완료
- 증여세/상속세 계산 정확도 100%
- 법정 평가서 양식 준수

---

### Phase 6: 통합 및 최적화

**목표**: 5대 평가법 통합 UI 및 성능 최적화

**주요 작업**:
- [ ] 5대 평가법 비교 대시보드 (Football Field Chart)
- [ ] 교차 검증 기능 (여러 평가법 동시 실행 및 비교)
- [ ] 가중평균 통합 평가액 산출
- [ ] 성능 최적화
  - 쿼리 최적화 (N+1 문제 해결)
  - Redis 캐싱 전략
  - 비동기 계산 처리 (Celery)
- [ ] 보안 강화
  - SQL Injection 방어
  - XSS 방어
  - CSRF 토큰
  - 데이터 암호화
- [ ] 감사 로그 시스템 (모든 평가 작업 추적)
- [ ] 사용자 매뉴얼 작성
- [ ] 통합 테스트 및 UAT (사용자 수용 테스트)
- [ ] 배포 및 모니터링 설정

**완료 기준**:
- 5대 평가법 동시 실행 시 응답 시간 < 30초
- 시스템 가용성 99% 이상
- 보안 취약점 스캔 통과
- 사용자 테스트 피드백 반영 완료

---

## 8. 즉시 시작 가능한 작업

### 우선순위 1: 공통 라이브러리 (Phase 1의 핵심)

```python
# FinancialMath 라이브러리 구현 예시
def present_value(cash_flows, discount_rate):
    """현재가치 계산"""
    pv = 0
    for t, cf in enumerate(cash_flows, start=1):
        pv += cf / ((1 + discount_rate) ** t)
    return pv

def wacc(risk_free, beta, mrp, cost_debt, debt_ratio, tax_rate):
    """WACC 계산"""
    cost_equity = risk_free + beta * mrp
    equity_ratio = 1 - debt_ratio
    return (equity_ratio * cost_equity) + (debt_ratio * cost_debt * (1 - tax_rate))
```

### 우선순위 2: 데이터 모델 설계

```sql
-- 기업 기본정보 테이블
CREATE TABLE companies (
    company_id VARCHAR(50) PRIMARY KEY,
    company_name VARCHAR(200),
    industry_code VARCHAR(20),
    listing_status VARCHAR(20),
    fiscal_year_end VARCHAR(5)
);

-- 재무제표 테이블
CREATE TABLE financial_statements (
    statement_id VARCHAR(50) PRIMARY KEY,
    company_id VARCHAR(50) REFERENCES companies(company_id),
    fiscal_year INT,
    statement_type VARCHAR(10),
    data JSONB
);
```

### 우선순위 3: DCF 프로토타입

- 간단한 CLI 기반 DCF 계산기
- Excel 입력 → Python 계산 → 텍스트 출력
- 핵심 로직 검증

---

## 부록: 주요 계산식 요약

### DCF
```
기업가치 = Σ[FCFt / (1+WACC)^t] + TV / (1+WACC)^n
TV = FCFn+1 / (WACC - g)
WACC = (E/V)×Re + (D/V)×Rd×(1-T)
```

### 상대가치
```
기업가치 = 재무지표 × 비교기업 배수 중앙값
PER = 시가총액 / 당기순이익
EV/EBITDA = 기업가치 / EBITDA
```

### 자산가치
```
NAV = 자산 시가 - 부채 시가
주당 NAV = NAV / 발행주식수
```

### 자본시장법
```
평가액 = (수익가치×1.5 + 자산가치×1) / 2.5
```

### 상증세법
```
평가액 = (순손익가치×3 + 순자산가치×2) / 5
순손익가치 = (3년 평균 순손익 / 주식수) / 0.10
```
